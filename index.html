<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>Stone Story Auto-Battler</title>
<style>
* { margin:0; padding:0; }
body { background:#000; overflow:hidden; display:flex; justify-content:center; align-items:center; height:100vh; }
canvas { display:block; image-rendering:pixelated; }
</style>
</head>
<body>
<canvas id="c" width="1000" height="600"></canvas>
<script>
// ============================================================
// STONE STORY RPG AUTO-BATTLER
// ============================================================

const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
const COLS = 100, ROWS = 37, CW = 10, CH = 16;
const W = 1000, H = 600;

// ============================================================
// COLOR GRID RENDERER
// ============================================================
const grid = [];
for (let r = 0; r < ROWS; r++) {
  grid[r] = [];
  for (let c = 0; c < COLS; c++) grid[r][c] = { ch: '', color: '#aaa' };
}

function clearGrid() {
  for (let r = 0; r < ROWS; r++)
    for (let c = 0; c < COLS; c++) { grid[r][c].ch = ''; grid[r][c].color = '#aaa'; }
}

function drawStr(col, row, str, color) {
  if (row < 0 || row >= ROWS) return;
  for (let i = 0; i < str.length; i++) {
    const c = col + i;
    if (c < 0 || c >= COLS) continue;
    grid[row][c].ch = str[i];
    grid[row][c].color = color || '#aaa';
  }
}

function drawBox(col, row, width, height, title, color) {
  const c = color || '#aaa';
  let top = '\u2554' + '\u2550'.repeat(width - 2) + '\u2557';
  if (title) {
    const pad = Math.max(0, Math.floor((width - 2 - title.length) / 2));
    top = '\u2554' + '\u2550'.repeat(pad) + title + '\u2550'.repeat(width - 2 - pad - title.length) + '\u2557';
  }
  drawStr(col, row, top, c);
  for (let r = 1; r < height - 1; r++) {
    drawStr(col, row + r, '\u2551', c);
    drawStr(col + width - 1, row + r, '\u2551', c);
  }
  drawStr(col, row + height - 1, '\u255A' + '\u2550'.repeat(width - 2) + '\u255D', c);
}

function drawBoxDivider(col, row, width, color) {
  drawStr(col, row, '\u255F' + '\u2500'.repeat(width - 2) + '\u2562', color || '#aaa');
}

function renderGrid() {
  ctx.fillStyle = '#000';
  ctx.fillRect(0, 0, W, H);
  ctx.font = '14px monospace';
  ctx.textBaseline = 'top';
  const buckets = {};
  for (let r = 0; r < ROWS; r++) {
    for (let c = 0; c < COLS; c++) {
      const cell = grid[r][c];
      if (!cell.ch || cell.ch === ' ') continue;
      if (!buckets[cell.color]) buckets[cell.color] = [];
      buckets[cell.color].push({ ch: cell.ch, x: c * CW, y: r * CH });
    }
  }
  for (const color in buckets) {
    ctx.fillStyle = color;
    for (const p of buckets[color]) ctx.fillText(p.ch, p.x, p.y);
  }
}

// ============================================================
// INPUT
// ============================================================
const keys = {};
const justPressed = {};
document.addEventListener('keydown', e => {
  if (!keys[e.key]) justPressed[e.key] = true;
  keys[e.key] = true;
  e.preventDefault();
});
document.addEventListener('keyup', e => { keys[e.key] = false; });
function wasPressed(k) { return justPressed[k] || justPressed[k.toLowerCase()] || justPressed[k.toUpperCase()]; }
function clearInput() { for (const k in justPressed) delete justPressed[k]; }

// Scroll wheel support
let scrollDelta = 0;
canvas.addEventListener('wheel', e => {
  scrollDelta += e.deltaY > 0 ? 1 : -1;
  e.preventDefault();
}, { passive: false });
function getScroll() { const d = scrollDelta; scrollDelta = 0; return d; }

// Sort/Filter system
const SORT_MODES = ['default', 'best', 'worst'];
const FILTER_RARITIES = ['all', 'common', 'uncommon', 'rare', 'epic', 'legendary'];
const FILTER_SLOTS = ['all', 'weapon', 'armor', 'accessory'];
let filterSort = 0;
let filterRarity = 0;
let filterSlot = 0;

function getFilteredItems(items) {
  let filtered = [...items];
  if (FILTER_RARITIES[filterRarity] !== 'all') {
    filtered = filtered.filter(i => i.rarity === FILTER_RARITIES[filterRarity]);
  }
  if (FILTER_SLOTS[filterSlot] !== 'all') {
    filtered = filtered.filter(i => i.slot === FILTER_SLOTS[filterSlot]);
  }
  if (SORT_MODES[filterSort] === 'best') {
    filtered.sort((a, b) => (b.tier || 0) - (a.tier || 0) || (b.attack || 0) - (a.attack || 0));
  } else if (SORT_MODES[filterSort] === 'worst') {
    filtered.sort((a, b) => (a.tier || 0) - (b.tier || 0) || (a.attack || 0) - (b.attack || 0));
  }
  return filtered;
}

function handleFilterKeys(cursorReset) {
  let changed = false;
  if (wasPressed('s') || wasPressed('S')) { filterSort = (filterSort + 1) % SORT_MODES.length; changed = true; }
  if (wasPressed('r') || wasPressed('R')) { filterRarity = (filterRarity + 1) % FILTER_RARITIES.length; changed = true; }
  if (wasPressed('t') || wasPressed('T')) { filterSlot = (filterSlot + 1) % FILTER_SLOTS.length; changed = true; }
  if (changed && cursorReset) cursorReset();
  return changed;
}

function drawFilterBar(row) {
  const sortLabel = SORT_MODES[filterSort].charAt(0).toUpperCase() + SORT_MODES[filterSort].slice(1);
  const rarLabel = FILTER_RARITIES[filterRarity].charAt(0).toUpperCase() + FILTER_RARITIES[filterRarity].slice(1);
  const slotLabel = FILTER_SLOTS[filterSlot].charAt(0).toUpperCase() + FILTER_SLOTS[filterSlot].slice(1);
  drawStr(3, row, `[S] Sort: ${sortLabel}`, '#adf');
  drawStr(25, row, `[R] Rarity: ${rarLabel}`, '#adf');
  drawStr(50, row, `[T] Slot: ${slotLabel}`, '#adf');
}

// ============================================================
// GAME STATE
// ============================================================
const STATE = {
  scene: 'camp',
  gold: 30,
  materials: { bone: 0, iron: 0, crystal: 0, shadow: 0, ember: 0 },
  unlockedAreas: 1,
  inventory: [],
  equipped: { weapon: null, armor: null, accessory: null },
  heroBaseStats: { maxHp: 50, attack: 5, defense: 2, critChance: 0.05, attackSpeed: 1.0 },
  currentArea: 0,
  wave: 0,
  heroHp: 50,
  heroMaxHp: 50,
  loot: [],
  lootGold: 0,
  lootMaterials: {},
  // EXP & Leveling
  exp: 0,
  level: 1,
  expToNext: 50
};

function getExpForLevel(level) {
  return 50 + (level - 1) * 30;
}

function addExp(amount) {
  STATE.exp += amount;
  while (STATE.exp >= STATE.expToNext) {
    STATE.exp -= STATE.expToNext;
    STATE.level++;
    STATE.expToNext = getExpForLevel(STATE.level);
    // Boost base stats
    STATE.heroBaseStats.maxHp += 5;
    STATE.heroBaseStats.attack += 1;
    STATE.heroBaseStats.defense += 1;
    STATE.heroBaseStats.critChance += 0.005;
    // Show level up text at hero position
    if (advState && advState.heroCol !== undefined) {
      addFloatingText(advState.heroCol - 2, advState.heroRow - 3, 'LEVEL UP!', '#ff0');
    } else {
      addFloatingText(40, 15, 'LEVEL UP!', '#ff0');
    }
  }
}

function getHeroStats() {
  const s = { ...STATE.heroBaseStats };
  for (const slot of ['weapon', 'armor', 'accessory']) {
    const item = STATE.equipped[slot];
    if (item) {
      s.maxHp += item.hp || 0;
      s.attack += item.attack || 0;
      s.defense += item.defense || 0;
      s.critChance += item.critChance || 0;
      s.attackSpeed += item.attackSpeed || 0;
      // Enchantment bonuses
      if (item.enchantment) {
        s.attack += item.enchantment.attack || 0;
        s.defense += item.enchantment.defense || 0;
        s.maxHp += item.enchantment.hp || 0;
        s.critChance += item.enchantment.critChance || 0;
        s.attackSpeed += item.enchantment.attackSpeed || 0;
      }
    }
  }
  return s;
}

function saveGame() {
  const data = {
    gold: STATE.gold,
    materials: STATE.materials,
    unlockedAreas: STATE.unlockedAreas,
    inventory: STATE.inventory,
    equipped: STATE.equipped,
    exp: STATE.exp,
    level: STATE.level,
    expToNext: STATE.expToNext,
    heroBaseStats: STATE.heroBaseStats
  };
  localStorage.setItem('stoneStoryAutoBattler', JSON.stringify(data));
}

function loadGame() {
  try {
    const raw = localStorage.getItem('stoneStoryAutoBattler');
    if (!raw) return;
    const d = JSON.parse(raw);
    STATE.gold = d.gold || 0;
    STATE.materials = d.materials || STATE.materials;
    STATE.unlockedAreas = d.unlockedAreas || 1;
    STATE.inventory = d.inventory || [];
    STATE.equipped = d.equipped || { weapon: null, armor: null, accessory: null };
    STATE.exp = d.exp || 0;
    STATE.level = d.level || 1;
    STATE.expToNext = d.expToNext || getExpForLevel(STATE.level);
    if (d.heroBaseStats) STATE.heroBaseStats = d.heroBaseStats;
  } catch(e) {}
}

// ============================================================
// AREAS DATA
// ============================================================
const AREAS = [
  {
    name: 'The Barren Fields',
    material: 'bone',
    bgColor: '#332',
    groundChar: '.',
    enemies: [
      { name: 'Skeleton', type: 'melee', sprite: [' O ','/†\\','/ \\'], walkSprite: [' O ','/†\\','/> '], attackSprite: [' O ','_†--','/ \\'], color: '#cba', hp: 20, attack: 4, defense: 1, speed: 0.8 },
      { name: 'Dire Rat', type: 'melee', sprite: ['/\\_/\\','( o.o)','> ‡ <'], walkSprite: ['/\\_/\\','( o.o)','>  ‡<'], attackSprite: ['/\\_/\\','(>o.o)>','> ‡ <'], color: '#987', hp: 15, attack: 5, defense: 0, speed: 1.2 }
    ],
    boss: { name: 'Bone Knight', type: 'melee', sprite: ['  [†]  ',' /###\\ ','/ |‡| \\','  | |  ','  d b  '], walkSprite: ['  [†]  ',' /###\\ ','/ |‡| \\','  | |  ','  d  b '], attackSprite: ['  [†]  ',' /###\\ ','--|‡| \\','  | |  ','  d b  '], color: '#fed', hp: 80, attack: 8, defense: 4, speed: 0.7 },
    landscape: { mountains: '/\\/\\_/\\', trees: '  +  \n /|\\ \n  |  ', ground: '...,,,___...,,,...' }
  },
  {
    name: 'Iron Mines',
    material: 'iron',
    bgColor: '#223',
    groundChar: '#',
    enemies: [
      { name: 'Goblin', type: 'melee', sprite: [' o ',"<|>",' A '], walkSprite: [' o ',"<|>",' A>'], attackSprite: [' o ',"-|>",' A '], color: '#5a5', hp: 25, attack: 7, defense: 2, speed: 1.0 },
      { name: 'Cave Bat', type: 'melee', sprite: ['/V\\','(o)'], walkSprite: ['/v\\','(o)'], attackSprite: ['/V\\','(O)>'], color: '#758', hp: 18, attack: 6, defense: 1, speed: 1.5 }
    ],
    boss: { name: 'Iron Golem', type: 'melee', sprite: [' [===] ','|#####|','|# O #|','|#####|',' ## ## '], walkSprite: [' [===] ','|#####|','|# O #|','|#####|',' ##  ##'], attackSprite: [' [===] ','|#####|','|# O #|--','|#####|',' ## ## '], color: '#8ab', hp: 120, attack: 10, defense: 7, speed: 0.5 },
    landscape: { mountains: '___/\\_/\\___', ground: '###===###===###' }
  },
  {
    name: 'Crystal Caverns',
    material: 'crystal',
    bgColor: '#224',
    groundChar: '*',
    enemies: [
      { name: 'Crystal Spider', type: 'melee', sprite: ['/✦o✦\\','\\ | /','/ | \\'], walkSprite: ['/✦o✦\\','\\>| /','/ |< '], attackSprite: ['/✦o✦\\','-\\|/-','/ | \\'], color: '#aaf', hp: 30, attack: 9, defense: 3, speed: 1.1 },
      { name: 'Shardling', type: 'ranged', sprite: ['◆\\','/  \\','/____\\'], walkSprite: ['◆\\','/ >\\','/____\\'], attackSprite: ['◆\\*','/  \\','/____\\'], projectileChar: '✦', color: '#adf', hp: 22, attack: 11, defense: 2, speed: 0.9 }
    ],
    boss: { name: 'Prism Wyrm', type: 'ranged', sprite: ['  /✦_____','<( O     >--','  \\◇_____'], walkSprite: ['  /✦_____','<( O    >-- ','  \\◇_____'], attackSprite: ['  /✦_____','<( O  ===>>','  \\◇_____'], projectileChar: '✦', color: '#daf', hp: 160, attack: 14, defense: 5, speed: 0.8 },
    landscape: { mountains: '/\\/\\/\\/\\', ground: '***<>***<>***' }
  },
  {
    name: 'Shadow Thicket',
    material: 'shadow',
    bgColor: '#112',
    groundChar: '~',
    enemies: [
      { name: 'Shadow Wolf', type: 'melee', sprite: ['/░\\_','( OO)','(░   )>'], walkSprite: ['/░\\_','( OO)','(░  )> '], attackSprite: ['/░\\_','(>OO)>','(░   )>'], color: '#668', hp: 35, attack: 12, defense: 4, speed: 1.3 },
      { name: 'Wraith', type: 'ranged', sprite: [' {O} ','▒/|\\▒','  ~  '], walkSprite: [' {O} ','▒/|\\▒','  ~~ '], attackSprite: [' {O} ','▒/|\\▒>~','  ~  '], projectileChar: '~', color: '#549', hp: 28, attack: 14, defense: 2, speed: 1.0 }
    ],
    boss: { name: 'Elder Treant', type: 'melee', sprite: ['  @@@@  ',' @@▓@@@','  ||||  ',' /||||\\','//░||░\\\\'], walkSprite: ['  @@@@  ',' @@▓@@@','  ||||  ',' /||||\\','//░ ||░\\\\'], attackSprite: ['  @@@@  ',' @@▓@@@','--||||  ',' /||||\\','//░||░\\\\'], color: '#5a4', hp: 200, attack: 16, defense: 8, speed: 0.4 },
    landscape: { mountains: '/\\_/\\_/\\', ground: '~~~|||~~~|||~~~' }
  },
  {
    name: 'The Ember Throne',
    material: 'ember',
    bgColor: '#321',
    groundChar: '^',
    enemies: [
      { name: 'Fire Imp', type: 'ranged', sprite: [' ▲ ','<o>','/ \\'], walkSprite: [' ▲ ','<o>','/ >'], attackSprite: [' ▲ ','<o>>*','/ \\'], projectileChar: '☆', color: '#f85', hp: 38, attack: 15, defense: 4, speed: 1.2 },
      { name: 'Lava Brute', type: 'melee', sprite: ['[ooo]','|O△O|',' |_| '], walkSprite: ['[ooo]','|O△O|',' |_|>'], attackSprite: ['[ooo]','-|O△O|',' |_| '], color: '#f63', hp: 50, attack: 18, defense: 7, speed: 0.6 },
      { name: 'Ash Wraith', type: 'ranged', sprite: [' {X} ','▒/|\\▒','  ^  '], walkSprite: [' {X} ','▒/|\\▒','  ^^ '], attackSprite: [' {X} ','▒/|\\▒>^','  ^  '], projectileChar: '^', color: '#a65', hp: 32, attack: 16, defense: 3, speed: 1.1 }
    ],
    boss: { name: 'Ember Lord', type: 'ranged', sprite: ['  \\▲/  ','--[O]--','  /M\\  ',' / | \\ ','_/ △ \\_'], walkSprite: ['  \\▲/  ','--[O]--','  /M\\  ',' / | \\ ','_/  △ \\_'], attackSprite: ['  \\▲/  ','--[O]-->>','  /M\\  ',' / | \\ ','_/ △ \\_'], projectileChar: '☆', color: '#fa3', hp: 280, attack: 22, defense: 10, speed: 0.6 },
    landscape: { mountains: '^/\\/^/\\/^', ground: '^^^vvv^^^vvv^^^' }
  }
];

// ============================================================
// EQUIPMENT DATA
// ============================================================
const RARITY_COLORS = { common: '#aaa', uncommon: '#5a5', rare: '#55f', epic: '#a5f', legendary: '#fa5' };
const RARITIES = ['common','uncommon','rare','epic','legendary'];

const EQUIPMENT_TABLE = [
  { name: 'Bone Sword', slot: 'weapon', tier: 0, rarity: 'common', attack: 3, defense: 0, hp: 0, critChance: 0.02, attackSpeed: 0, cost: 15 },
  { name: 'Bone Shield', slot: 'armor', tier: 0, rarity: 'common', attack: 0, defense: 3, hp: 10, critChance: 0, attackSpeed: 0, cost: 15 },
  { name: 'Rat Tooth Charm', slot: 'accessory', tier: 0, rarity: 'common', attack: 1, defense: 0, hp: 5, critChance: 0.05, attackSpeed: 0.1, cost: 12 },
  { name: 'Iron Blade', slot: 'weapon', tier: 1, rarity: 'uncommon', attack: 6, defense: 0, hp: 0, critChance: 0.03, attackSpeed: 0.1, cost: 35 },
  { name: 'Iron Plate', slot: 'armor', tier: 1, rarity: 'uncommon', attack: 0, defense: 6, hp: 20, critChance: 0, attackSpeed: -0.1, cost: 35 },
  { name: 'Goblin Earring', slot: 'accessory', tier: 1, rarity: 'uncommon', attack: 2, defense: 1, hp: 10, critChance: 0.05, attackSpeed: 0.15, cost: 30 },
  { name: 'Crystal Saber', slot: 'weapon', tier: 2, rarity: 'rare', attack: 10, defense: 0, hp: 5, critChance: 0.08, attackSpeed: 0.15, cost: 60 },
  { name: 'Crystal Mail', slot: 'armor', tier: 2, rarity: 'rare', attack: 0, defense: 10, hp: 35, critChance: 0, attackSpeed: 0, cost: 60 },
  { name: 'Prism Pendant', slot: 'accessory', tier: 2, rarity: 'rare', attack: 4, defense: 2, hp: 15, critChance: 0.1, attackSpeed: 0.1, cost: 55 },
  { name: 'Shadow Fang', slot: 'weapon', tier: 3, rarity: 'epic', attack: 15, defense: 0, hp: 0, critChance: 0.12, attackSpeed: 0.2, cost: 100 },
  { name: 'Treant Bark', slot: 'armor', tier: 3, rarity: 'epic', attack: 0, defense: 14, hp: 50, critChance: 0, attackSpeed: 0, cost: 100 },
  { name: 'Wraith Ring', slot: 'accessory', tier: 3, rarity: 'epic', attack: 6, defense: 3, hp: 20, critChance: 0.1, attackSpeed: 0.2, cost: 90 },
  { name: 'Ember Blade', slot: 'weapon', tier: 4, rarity: 'legendary', attack: 22, defense: 0, hp: 10, critChance: 0.15, attackSpeed: 0.25, cost: 180 },
  { name: 'Molten Aegis', slot: 'armor', tier: 4, rarity: 'legendary', attack: 2, defense: 20, hp: 70, critChance: 0, attackSpeed: 0, cost: 180 },
  { name: 'Ember Crown', slot: 'accessory', tier: 4, rarity: 'legendary', attack: 8, defense: 5, hp: 30, critChance: 0.12, attackSpeed: 0.2, cost: 160 }
];

function generateDrop(areaTier) {
  const pool = EQUIPMENT_TABLE.filter(e => e.tier <= areaTier);
  const weighted = [];
  for (const item of pool) {
    const weight = item.tier === areaTier ? 4 : 1;
    for (let i = 0; i < weight; i++) weighted.push(item);
  }
  return { ...weighted[Math.floor(Math.random() * weighted.length)] };
}

// ============================================================
// FORGE RECIPES
// ============================================================
const FORGE_MATERIAL_COSTS = [
  { material: 'bone', amount: 3, gold: 10 },
  { material: 'iron', amount: 5, gold: 25 },
  { material: 'crystal', amount: 5, gold: 50 },
  { material: 'shadow', amount: 7, gold: 80 },
  { material: 'ember', amount: 10, gold: 120 }
];

// ============================================================
// ENCHANTMENTS
// ============================================================
const ENCHANTMENTS = [
  { name: 'Bone Curse', material: 'bone', area: 0, attack: 3, defense: 0, hp: 0, critChance: 0, attackSpeed: 0, desc: '+3 ATK, lifesteal', color: '#cba' },
  { name: 'Iron Ward', material: 'iron', area: 1, attack: 0, defense: 5, hp: 15, critChance: 0, attackSpeed: 0, desc: '+5 DEF, +15 HP', color: '#8ab' },
  { name: 'Crystal Pierce', material: 'crystal', area: 2, attack: 2, defense: 0, hp: 0, critChance: 0.08, attackSpeed: 0, desc: '+8% CRIT, +2 ATK', color: '#aaf' },
  { name: 'Shadow Strike', material: 'shadow', area: 3, attack: 4, defense: 0, hp: 0, critChance: 0, attackSpeed: 0.3, desc: '+0.3 SPD, +4 ATK', color: '#549' },
  { name: 'Ember Fury', material: 'ember', area: 4, attack: 6, defense: 0, hp: 0, critChance: 0.05, attackSpeed: 0, desc: '+6 ATK, +5% CRIT', color: '#fa3' }
];

// ============================================================
// PARTICLES & EFFECTS
// ============================================================
let particles = [];
let floatingTexts = [];
let heroProjectiles = [];

function addParticle(x, y, ch, color, vx, vy, life) {
  particles.push({ x, y, ch, color, vx, vy, life, maxLife: life });
}

function addFloatingText(col, row, text, color) {
  floatingTexts.push({ col, row, text, color, life: 40 });
}

function updateParticles() {
  for (let i = particles.length - 1; i >= 0; i--) {
    const p = particles[i];
    p.x += p.vx;
    p.y += p.vy;
    p.life--;
    if (p.life <= 0) particles.splice(i, 1);
  }
  for (let i = floatingTexts.length - 1; i >= 0; i--) {
    const ft = floatingTexts[i];
    ft.row -= 0.08;
    ft.life--;
    if (ft.life <= 0) floatingTexts.splice(i, 1);
  }
}

function drawParticles() {
  for (const p of particles) {
    const col = Math.round(p.x);
    const row = Math.round(p.y);
    if (col >= 0 && col < COLS && row >= 0 && row < ROWS) {
      grid[row][col].ch = p.ch;
      grid[row][col].color = p.color;
    }
  }
  for (const ft of floatingTexts) {
    const row = Math.round(ft.row);
    const col = Math.round(ft.col);
    if (row >= 0 && row < ROWS) {
      drawStr(col, row, ft.text, ft.color);
    }
  }
}

// ============================================================
// CAMPFIRE ANIMATION
// ============================================================
let campFrame = 0;
const FIRE_CHARS = ['{', '}', '*', '^', '~', '"'];
const FIRE_COLORS = ['#f83', '#fa4', '#fc6', '#f62', '#fd8'];

function drawCampfire(cx, cy) {
  drawStr(cx - 2, cy + 2, '\\===/', '#864');
  drawStr(cx - 1, cy + 3, '===', '#753');
  for (let i = 0; i < 6; i++) {
    const fx = cx - 1 + Math.floor(Math.random() * 3);
    const fy = cy - Math.floor(Math.random() * 2) + 1;
    const ch = FIRE_CHARS[Math.floor(Math.random() * FIRE_CHARS.length)];
    const col = FIRE_COLORS[Math.floor(Math.random() * FIRE_COLORS.length)];
    if (fy >= 0 && fy < ROWS && fx >= 0 && fx < COLS) {
      grid[fy][fx].ch = ch;
      grid[fy][fx].color = col;
    }
  }
  if (Math.random() < 0.3) {
    addParticle(cx + (Math.random() - 0.5) * 2, cy - 1, '.', '#fa4',
      (Math.random() - 0.5) * 0.1, -0.15, 15 + Math.floor(Math.random() * 10));
  }
}

// ============================================================
// HERO SPRITE
// ============================================================
const HERO_IDLE = [' O ','/|\\','/ \\'];
const HERO_WALK = [' O ','/|\\','/ >'];
const HERO_ATTACK = [' O ','_|--','/ \\'];
const HERO_COLOR = '#8cf';

function drawSprite(sprite, col, row, color) {
  for (let i = 0; i < sprite.length; i++) {
    drawStr(col, row + i, sprite[i], color);
  }
}

// ============================================================
// COMBAT RANGE CONSTANTS
// ============================================================
const MELEE_RANGE = 5;
const RANGED_RANGE = 25;

// ============================================================
// CAMP SCENE
// ============================================================
let campMenuIndex = 0;

function updateCamp() {
  if (wasPressed('c') || wasPressed('C')) {
    STATE.scene = 'areaSelect';
    return;
  }
  if (wasPressed('f') || wasPressed('F')) {
    if (STATE.unlockedAreas >= 2) {
      initForge();
      filterSort = 0; filterRarity = 0; filterSlot = 0;
      STATE.scene = 'forge';
    }
    return;
  }
  if (wasPressed('e') || wasPressed('E')) {
    invCursor = 0;
    filterSort = 0; filterRarity = 0; filterSlot = 0;
    STATE.scene = 'inventory';
    return;
  }
  if (wasPressed('n') || wasPressed('N')) {
    if (STATE.unlockedAreas >= 2) {
      initEnchant();
      filterSort = 0; filterRarity = 0; filterSlot = 0;
      STATE.scene = 'enchant';
    }
    return;
  }
}

function drawCamp() {
  campFrame++;

  drawBox(0, 0, 100, 3, ' S T O N E   S T O R Y   A U T O - B A T T L E R ', '#888');

  const stats = getHeroStats();
  drawBox(1, 4, 28, 20, ' HERO STATS ', '#fd0');
  drawStr(3, 6, `Gold: ${STATE.gold}`, '#fd0');
  drawBoxDivider(1, 7, 28, '#553');
  drawStr(3, 8, `Level: ${STATE.level}`, '#adf');
  drawStr(3, 9, `EXP: ${STATE.exp}/${STATE.expToNext}`, '#8cf');
  drawStr(3, 10, `HP:   ${stats.maxHp}`, '#5a5');
  drawStr(3, 11, `ATK:  ${stats.attack}`, '#f85');
  drawStr(3, 12, `DEF:  ${stats.defense}`, '#58f');
  drawStr(3, 13, `CRIT: ${(stats.critChance*100).toFixed(0)}%`, '#ff0');
  drawStr(3, 14, `SPD:  ${stats.attackSpeed.toFixed(1)}`, '#adf');
  drawBoxDivider(1, 15, 28, '#553');
  drawStr(3, 16, 'Equipped:', '#aaa');
  for (const slot of ['weapon','armor','accessory']) {
    const item = STATE.equipped[slot];
    const row = slot === 'weapon' ? 17 : slot === 'armor' ? 18 : 19;
    const name = item ? item.name : '(none)';
    drawStr(3, row, `${slot}: ${name}`, item ? RARITY_COLORS[item.rarity] : '#555');
  }
  drawBoxDivider(1, 20, 28, '#553');
  drawStr(3, 21, 'Materials:', '#aaa');
  let matRow = 22;
  for (const m in STATE.materials) {
    if (STATE.materials[m] > 0) {
      drawStr(3, matRow, `${m}: ${STATE.materials[m]}`, '#888');
      matRow++;
    }
  }

  // Center: Scenic area
  const starSeed = campFrame * 0.01;
  for (let c = 30; c < 70; c++) {
    for (let r = 4; r < 10; r++) {
      const hash = ((c * 127 + r * 311) % 97);
      if (hash < 3) {
        const twinkle = Math.sin(campFrame * 0.05 + hash) > 0.3;
        if (twinkle) drawStr(c, r, '.', '#556');
      }
    }
  }
  for (let c = 30; c < 70; c++) {
    const mc = (c - 30) % 40;
    const mh = Math.sin(mc * 0.18) * 3 + Math.sin(mc * 0.07) * 2 + 5;
    const baseRow = 16;
    for (let r = baseRow - Math.floor(mh); r < baseRow; r++) {
      if (r >= 4 && r < 20) drawStr(c, r, '.', '#333');
    }
  }
  const hx = 44, hy = 16;
  const heroFrame = campFrame % 60 < 30 ? HERO_IDLE : HERO_WALK;
  drawSprite(heroFrame, hx, hy, HERO_COLOR);
  drawCampfire(hx + 8, hy);

  // Right panel: CAMP MENU
  drawBox(71, 4, 28, 20, ' CAMP MENU ', '#8cf');
  drawStr(73, 7, '[C] Adventure', '#ddd');
  const forgeUnlocked = STATE.unlockedAreas >= 2;
  drawStr(73, 9, '[F] Forge', forgeUnlocked ? '#ddd' : '#555');
  if (!forgeUnlocked) drawStr(83, 9, '(locked)', '#444');
  drawStr(73, 11, '[E] Inventory', '#ddd');
  drawStr(73, 13, '[N] Enchant', forgeUnlocked ? '#ddd' : '#555');
  if (!forgeUnlocked) drawStr(85, 13, '(locked)', '#444');
  drawBoxDivider(71, 15, 28, '#446');
  drawStr(73, 17, `Areas: ${STATE.unlockedAreas}/5`, '#888');
  drawStr(73, 19, 'Venture forth and', '#555');
  drawStr(73, 20, 'conquer the stone', '#555');
  drawStr(73, 21, 'lands...', '#555');

  // Ground fill
  for (let c = 0; c < COLS; c++) {
    drawStr(c, 20, '_', '#665');
    for (let r = 21; r < 24; r++) {
      const hash = ((c * 13 + r * 7) % 5);
      const ch = hash === 0 ? ',' : hash === 1 ? '.' : hash === 2 ? '_' : hash === 3 ? ';' : '.';
      drawStr(c, r, ch, '#443');
    }
  }
}

// ============================================================
// AREA SELECT SCENE
// ============================================================
let areaSelectCursor = 0;

function updateAreaSelect() {
  if (wasPressed('ArrowUp') && areaSelectCursor > 0) areaSelectCursor--;
  if (wasPressed('ArrowDown') && areaSelectCursor < 4) areaSelectCursor++;
  if (wasPressed('ArrowLeft') && areaSelectCursor > 0) areaSelectCursor--;
  if (wasPressed('ArrowRight') && areaSelectCursor < 4) areaSelectCursor++;
  if (wasPressed('Escape')) { STATE.scene = 'camp'; return; }
  if (wasPressed('Enter')) {
    if (areaSelectCursor < STATE.unlockedAreas) {
      STATE.currentArea = areaSelectCursor;
      initAdventure();
      STATE.scene = 'adventure';
    }
  }
  for (let i = 0; i < 5; i++) {
    if (wasPressed(String(i + 1)) && i < STATE.unlockedAreas) {
      STATE.currentArea = i;
      initAdventure();
      STATE.scene = 'adventure';
    }
  }
}

function drawAreaSelect() {
  drawBox(0, 0, 100, 3, ' S E L E C T   A R E A ', '#ddd');

  for (let i = 0; i < 5; i++) {
    const unlocked = i < STATE.unlockedAreas;
    const selected = i === areaSelectCursor;
    const col = 1 + i * 19 + i;
    const borderColor = selected ? (unlocked ? '#fff' : '#555') : (unlocked ? '#666' : '#333');
    drawBox(col, 4, 19, 7, null, borderColor);
    const name = unlocked ? AREAS[i].name : '???';
    const nameColor = selected ? (unlocked ? '#fff' : '#555') : (unlocked ? '#aaa' : '#444');
    drawStr(col + 2, 5, `${i + 1}`, '#888');
    drawStr(col + 2, 6, name.substring(0, 15), nameColor);
    if (unlocked) {
      drawStr(col + 2, 7, AREAS[i].material, '#888');
      const diff = ['Easy','Medium','Hard','Very Hard','Extreme'];
      drawStr(col + 2, 8, diff[i], i < 2 ? '#5a5' : i < 4 ? '#fa5' : '#f55');
    }
    if (selected) drawStr(col + 2, 9, '\u25B2', '#fff');
  }

  drawBox(1, 12, 98, 18, ' AREA DETAILS ', '#888');
  const sel = areaSelectCursor;
  if (sel < STATE.unlockedAreas) {
    const area = AREAS[sel];
    drawStr(3, 14, area.name, '#fff');
    drawStr(3, 15, `Material: ${area.material}`, '#aaa');
    drawBoxDivider(1, 16, 98, '#555');
    drawStr(3, 17, 'Enemies:', '#aaa');
    for (let e = 0; e < area.enemies.length; e++) {
      const en = area.enemies[e];
      drawStr(5, 18 + e, `${en.name}  HP:${en.hp} ATK:${en.attack} DEF:${en.defense}`, en.color);
    }
    drawStr(3, 21, 'Boss:', '#f55');
    drawStr(5, 22, `${area.boss.name}  HP:${area.boss.hp} ATK:${area.boss.attack} DEF:${area.boss.defense}`, area.boss.color);
    for (let c = 65; c < 97; c++) {
      const mc = (c - 65) % 32;
      const mh = Math.sin(mc * 0.2) * 2 + 3;
      for (let r = 18; r < 18 + Math.floor(mh); r++) {
        if (r < 28) drawStr(c, r, '.', '#444');
      }
      drawStr(c, 25, area.groundChar, '#554');
    }
  } else {
    drawStr(3, 14, '???', '#555');
    drawStr(3, 16, 'Locked - defeat the previous boss to unlock', '#555');
  }

  drawBox(0, 31, 100, 6, ' CONTROLS ', '#555');
  drawStr(3, 33, 'Arrow keys / Left-Right to select    Enter to begin    Escape to go back    1-5 to quick-select', '#666');
}

// ============================================================
// ADVENTURE SCENE (Auto-Battler Core) — 2x Slower
// ============================================================
let advState = {};

function initAdventure() {
  const stats = getHeroStats();
  STATE.heroHp = stats.maxHp;
  STATE.heroMaxHp = stats.maxHp;
  STATE.wave = 0;
  STATE.loot = [];
  STATE.lootGold = 0;
  STATE.lootMaterials = {};
  particles = [];
  floatingTexts = [];
  heroProjectiles = [];
  advState = {
    scrollX: 0,
    heroCol: 20,
    heroRow: 26,
    heroAttackTimer: 0,
    heroAttackAnim: 0,
    heroHitFlash: 0,
    enemies: [],
    phase: 'walking', // walking, combat, bossIntro, transition, chest, victory
    walkTimer: 0,
    waveSpawned: false,
    transitionTimer: 0,
    bossIntroTimer: 0,
    frame: 0,
    walkCycle: 0,
    // Chest state
    chestItem: null,
    chestGold: 0,
    chestMaterials: {},
    showChest: false
  };
  spawnWave();
}

function spawnWave() {
  const area = AREAS[STATE.currentArea];
  advState.enemies = [];
  const isBoss = STATE.wave === 4;
  if (isBoss) {
    const b = area.boss;
    const targetRange = b.type === 'ranged' ? RANGED_RANGE : MELEE_RANGE;
    advState.enemies.push({
      ...b,
      sprite: b.sprite,
      currentHp: b.hp,
      maxHp: b.hp,
      col: 85,
      row: advState.heroRow - (b.sprite.length - 3),
      attackTimer: 0,
      attackAnim: 0,
      hitFlash: 0,
      isBoss: true,
      deathAnim: 0,
      alive: true,
      walkCycle: 0,
      targetRange: targetRange
    });
    advState.phase = 'bossIntro';
    advState.bossIntroTimer = 60;
  } else {
    const count = 2 + Math.floor(Math.random() * 2);
    const staggerCols = [75, 83, 91, 79];
    const staggerRows = [0, -2, 1, -1];
    for (let i = 0; i < count; i++) {
      const template = area.enemies[Math.floor(Math.random() * area.enemies.length)];
      const targetRange = template.type === 'ranged' ? RANGED_RANGE : MELEE_RANGE;
      advState.enemies.push({
        ...template,
        sprite: template.sprite,
        currentHp: template.hp,
        maxHp: template.hp,
        col: staggerCols[i] || (75 + i * 8),
        row: advState.heroRow + (3 - template.sprite.length) + (staggerRows[i] || 0),
        attackTimer: 0,
        attackAnim: 0,
        hitFlash: 0,
        isBoss: false,
        deathAnim: 0,
        alive: true,
        walkCycle: 0,
        targetRange: targetRange
      });
    }
    advState.phase = 'walking';
    advState.walkTimer = 120; // 2x slower (was 60)
  }
  advState.waveSpawned = true;
}

function handleEnemyDeath(target) {
  target.alive = false;
  target.deathAnim = 30;
  // Death explosion
  for (const line of target.sprite) {
    for (const ch of line) {
      if (ch !== ' ') {
        addParticle(target.col + Math.random()*6, target.row + Math.random()*4,
          ch, target.color, (Math.random()-0.5)*0.7, (Math.random()-0.5)*0.5, 35);
      }
    }
  }
  for (let i = 0; i < 6; i++) {
    const angle = (i / 6) * Math.PI * 2;
    addParticle(target.col + 2, target.row + 1,
      '*', '#fff', Math.cos(angle) * 0.6, Math.sin(angle) * 0.4, 20);
  }
  for (let i = 0; i < 4; i++) {
    addParticle(target.col + Math.random()*5, target.row + Math.random()*3,
      '\u2591', '#555', (Math.random()-0.5)*0.05, -0.03, 40);
  }

  const goldDrop = 3 + Math.floor(Math.random() * 5) + STATE.currentArea * 2;
  STATE.lootGold += goldDrop;
  addFloatingText(target.col, target.row - 2, `+${goldDrop}g`, '#fd0');

  const expAmount = target.isBoss
    ? 25 + STATE.currentArea * 10
    : 5 + STATE.currentArea * 3;
  addExp(expAmount);
  addFloatingText(target.col + 4, target.row - 2, `+${expAmount}exp`, '#0ff');

  if (Math.random() < 0.3) {
    const mat = AREAS[STATE.currentArea].material;
    STATE.lootMaterials[mat] = (STATE.lootMaterials[mat] || 0) + 1;
  }

  if (target.isBoss) {
    advState.chestItem = generateDrop(STATE.currentArea);
    advState.chestGold = 15 + STATE.currentArea * 10;
    const mat = AREAS[STATE.currentArea].material;
    const matCount = 2 + Math.floor(Math.random() * 2);
    advState.chestMaterials = {};
    advState.chestMaterials[mat] = matCount;
    advState.showChest = true;
  }
}

function updateHeroProjectiles() {
  for (let i = heroProjectiles.length - 1; i >= 0; i--) {
    const p = heroProjectiles[i];
    p.x += p.vx;

    // Trail particles
    if (Math.random() < 0.5) {
      addParticle(p.x - 1, p.y + 1, '\u00B7', p.isCrit ? '#ff0' : '#aaa', -0.3, (Math.random()-0.5)*0.1, 8);
    }

    // Check collision with alive enemies
    for (const e of advState.enemies) {
      if (!e.alive) continue;
      if (p.hitEnemies.has(e)) continue;
      if (Math.abs(p.x - e.col) < 3) {
        e.currentHp -= p.dmg;
        e.hitFlash = 9;
        p.hitEnemies.add(e);

        if (p.isCrit) {
          addFloatingText(e.col, e.row - 1, 'CRIT! ' + String(p.dmg), '#ff0');
          const burstChars = ['*', '\u2605', '*', '\u2605'];
          for (let j = 0; j < 8; j++) {
            const angle = (j / 8) * Math.PI * 2;
            addParticle(e.col + 2, e.row + 1,
              burstChars[j % burstChars.length], '#ff0',
              Math.cos(angle) * 0.5, Math.sin(angle) * 0.3, 14);
          }
        } else {
          addFloatingText(e.col, e.row - 1, String(p.dmg), '#fff');
        }

        if (e.currentHp <= 0) {
          handleEnemyDeath(e);
        }

        p.dmg = Math.floor(p.dmg * 0.8);
        p.pierceLeft--;
        if (p.pierceLeft <= 0) {
          heroProjectiles.splice(i, 1);
          break;
        }
      }
    }

    // Remove if off-screen
    if (p.x > 100) {
      heroProjectiles.splice(i, 1);
    }
  }
}

function updateAdventure() {
  advState.frame++;
  const stats = getHeroStats();

  if (advState.phase === 'bossIntro') {
    advState.bossIntroTimer--;
    if (advState.bossIntroTimer <= 0) advState.phase = 'combat';
    return;
  }

  if (advState.phase === 'walking') {
    advState.scrollX += 0.25; // 2x slower (was 0.5)
    advState.walkCycle++;
    advState.walkTimer--;
    for (const e of advState.enemies) {
      const targetCol = advState.heroCol + e.targetRange;
      if (e.col > targetCol + 1) {
        e.col -= 0.25; // 2x slower (was 0.5)
        e.walkCycle = (e.walkCycle || 0) + 1;
      }
    }
    if (advState.walkTimer <= 0) {
      advState.phase = 'combat';
    }
    return;
  }

  if (advState.phase === 'transition') {
    advState.transitionTimer--;
    advState.scrollX += 0.15; // 2x slower (was 0.3)
    if (advState.transitionTimer <= 0) {
      STATE.wave++;
      if (STATE.wave >= 5) {
        advState.phase = 'victory';
      } else {
        spawnWave();
      }
    }
    return;
  }

  // Chest screen after boss kill
  if (advState.phase === 'chest') {
    if (wasPressed('Enter')) {
      // Collect chest contents
      if (advState.chestItem) {
        STATE.loot.push(advState.chestItem);
      }
      STATE.lootGold += advState.chestGold;
      for (const m in advState.chestMaterials) {
        STATE.lootMaterials[m] = (STATE.lootMaterials[m] || 0) + advState.chestMaterials[m];
      }
      // Move to transition
      advState.phase = 'transition';
      advState.transitionTimer = 80; // 2x slower (was 40)
    }
    return;
  }

  if (advState.phase === 'victory') {
    if (wasPressed('Enter')) {
      for (const item of STATE.loot) STATE.inventory.push(item);
      STATE.gold += STATE.lootGold;
      for (const m in STATE.lootMaterials) STATE.materials[m] = (STATE.materials[m] || 0) + STATE.lootMaterials[m];
      if (STATE.currentArea + 1 >= STATE.unlockedAreas && STATE.unlockedAreas < 5) {
        STATE.unlockedAreas++;
      }
      saveGame();
      heroProjectiles = [];
      STATE.scene = 'camp';
    }
    return;
  }

  if (advState.phase !== 'combat') return;

  // Hero attack — 2x slower (8.33 instead of 16.67)
  advState.heroAttackTimer += 8.33;
  const heroAtkInterval = 1000 / stats.attackSpeed;
  if (advState.heroAttackAnim > 0) advState.heroAttackAnim--;
  if (advState.heroHitFlash > 0) advState.heroHitFlash--;

  if (advState.heroAttackTimer >= heroAtkInterval) {
    advState.heroAttackTimer = 0;
    let hasAlive = advState.enemies.some(e => e.alive);
    if (hasAlive) {
      advState.heroAttackAnim = 36;
      const isCrit = Math.random() < stats.critChance;
      // Use lowest-defense alive enemy for base damage calc
      let minDef = 999;
      for (const e of advState.enemies) {
        if (e.alive && e.defense < minDef) minDef = e.defense;
      }
      let dmg = Math.max(1, stats.attack - minDef);
      if (isCrit) dmg *= 2;

      // Spawn projectile
      heroProjectiles.push({
        x: advState.heroCol + 3,
        y: advState.heroRow,
        vx: 2.0,
        vy: 0,
        dmg,
        isCrit,
        pierceLeft: 3,
        hitEnemies: new Set()
      });

      // Slash launch particles
      const slashChars = ['/', '|', '\\'];
      for (let i = 0; i < 4; i++) {
        const ch = slashChars[i % slashChars.length];
        addParticle(advState.heroCol + 3 + i * 1.5, advState.heroRow - 1 + i * 0.5,
          ch, '#fff', 1.0, (i - 1.5) * 0.15, 10);
      }
    }
  }

  // Update hero projectiles
  updateHeroProjectiles();

  // Enemy movement and attacks
  for (const e of advState.enemies) {
    if (!e.alive) continue;
    if (e.hitFlash > 0) e.hitFlash--;
    if (e.attackAnim > 0) e.attackAnim--;

    const distToHero = e.col - advState.heroCol;
    const inRange = distToHero <= e.targetRange + 1;

    if (!inRange) {
      e.col -= 0.2; // 2x slower (was 0.4)
      e.walkCycle = (e.walkCycle || 0) + 1;
      continue;
    }

    e.attackTimer += 8.33; // 2x slower (was 16.67)
    const interval = 1000 / (e.speed || 1);
    if (e.attackTimer >= interval) {
      e.attackTimer = 0;
      e.attackAnim = 30; // 2x slower (was 15)
      const dmg = Math.max(1, e.attack - stats.defense);
      STATE.heroHp -= dmg;
      advState.heroHitFlash = 9;
      addFloatingText(advState.heroCol, advState.heroRow - 1, String(dmg), '#f55');

      if (e.type === 'ranged') {
        const pChar = e.projectileChar || '-';
        const pDist = e.col - advState.heroCol;
        const pSpeed = -1.5;
        addParticle(e.col, e.row + 1, pChar, e.color, pSpeed, 0, Math.ceil(pDist / 1.5));
        addParticle(e.col - 1, e.row + 1, pChar, e.color, pSpeed, 0, Math.ceil(pDist / 1.5));
        addParticle(e.col + 1, e.row + 1, '.', '#666', pSpeed * 0.7, 0, Math.ceil(pDist / 2.5));
      } else {
        const impactChars = ['\u2573', '\u203B', '*'];
        const ic = impactChars[Math.floor(Math.random() * impactChars.length)];
        addParticle(advState.heroCol + 1, advState.heroRow + 1, ic, '#f55', -0.2, 0, 10);
        addParticle(advState.heroCol + 2, advState.heroRow, '*', '#f88', -0.15, -0.1, 8);
      }

      if (STATE.heroHp <= 0) {
        STATE.heroHp = 0;
        STATE.gold = Math.floor(STATE.gold / 2);
        heroProjectiles = [];
        STATE.scene = 'gameOver';
        return;
      }
    }
  }

  // Check all enemies dead (clear projectiles on wave end)
  if (advState.enemies.every(e => !e.alive && e.deathAnim <= 0)) {
    heroProjectiles = [];
    // If boss was killed, show chest screen
    if (advState.showChest) {
      advState.phase = 'chest';
      advState.showChest = false;
    } else {
      advState.phase = 'transition';
      advState.transitionTimer = 80; // 2x slower (was 40)
    }
  }

  // Decrement death anims
  for (const e of advState.enemies) {
    if (!e.alive && e.deathAnim > 0) e.deathAnim--;
  }
}

function drawEnemyAura(enemy, areaIdx, frame, enemyIndex) {
  if (!enemy.alive) return;
  const rate = enemy.isBoss ? 4 : 8;
  if (frame % rate !== 0) return;
  const spread = enemy.isBoss ? 4 : 2;
  const cx = enemy.col + 2;
  const cy = enemy.row + 1;
  const rx = (Math.random() - 0.5) * (spread * 2 + enemy.sprite[0].length);
  const ry = (Math.random() - 0.5) * (spread + enemy.sprite.length);
  if (areaIdx === 0) {
    const ch = Math.random() < 0.5 ? '\u00B7' : '\u00B0';
    addParticle(cx + rx, cy + ry, ch, '#776', (Math.random()-0.5)*0.05, 0.08, 18);
  } else if (areaIdx === 1) {
    const ch = Math.random() < 0.5 ? '*' : '+';
    addParticle(cx + rx, cy + ry, ch, '#8ab', (Math.random()-0.5)*0.15, (Math.random()-0.5)*0.15, 12);
  } else if (areaIdx === 2) {
    const chars = ['\u2726', '\u25C6', '*'];
    const ch = chars[Math.floor(Math.random() * chars.length)];
    const colors = ['#aaf', '#daf', '#88d'];
    addParticle(cx + rx, cy + ry, ch, colors[Math.floor(Math.random() * colors.length)], (Math.random()-0.5)*0.1, -0.06, 20);
  } else if (areaIdx === 3) {
    const ch = Math.random() < 0.5 ? '~' : '\u2591';
    addParticle(cx + rx, cy + ry, ch, '#549', (Math.random()-0.5)*0.1, -0.04, 22);
  } else if (areaIdx === 4) {
    const chars = ['^', '*', '\u00B7'];
    const ch = chars[Math.floor(Math.random() * chars.length)];
    const colors = ['#f85', '#f63', '#fa4'];
    addParticle(cx + rx, cy + ry, ch, colors[Math.floor(Math.random() * colors.length)], (Math.random()-0.5)*0.08, -0.12, 16);
  }
}

function drawAdventure() {
  const area = AREAS[STATE.currentArea];

  drawLandscape(area);

  // Hero
  let heroSprite = HERO_IDLE;
  let heroColor = HERO_COLOR;
  if (advState.phase === 'walking') {
    heroSprite = advState.walkCycle % 40 < 20 ? HERO_WALK : HERO_IDLE; // 2x slower (was %20 <10)
  }
  if (advState.heroAttackAnim > 0) heroSprite = HERO_ATTACK;
  if (advState.heroHitFlash > 0 && advState.heroHitFlash % 2 === 0) heroColor = '#f33';
  drawSprite(heroSprite, advState.heroCol, advState.heroRow, heroColor);

  // Enemies
  for (let ei = 0; ei < advState.enemies.length; ei++) {
    const e = advState.enemies[ei];
    if (!e.alive) continue;
    let eColor = e.color;
    if (e.hitFlash > 0 && e.hitFlash % 2 === 0) eColor = '#f33';
    let eSprite = e.sprite;
    const distToHero = e.col - advState.heroCol;
    const isMoving = distToHero > e.targetRange + 1;
    let isIdle = false;
    if (e.attackAnim > 0) {
      eSprite = e.attackSprite || e.sprite;
      eColor = '#fff';
    } else if (isMoving || advState.phase === 'walking') {
      const cycle = e.walkCycle || 0;
      eSprite = (cycle % 40 < 20) ? (e.walkSprite || e.sprite) : e.sprite; // 2x slower (was %20 <10)
    } else {
      isIdle = true;
      if (Math.floor((advState.frame + ei * 17) / 40) % 2 === 1) {
        eSprite = e.walkSprite || e.sprite;
      }
    }
    const bobOffset = isIdle ? Math.sin(advState.frame * 0.06 + ei) * 0.5 : 0;
    const drawRow = Math.round(e.row + bobOffset);
    const knockCol = (e.hitFlash > 6) ? 1 : 0;
    drawSprite(eSprite, Math.round(e.col) + knockCol, drawRow, eColor);
    drawEnemyAura(e, STATE.currentArea, advState.frame, ei);
    if (!e.isBoss) {
      const barW = 8;
      const filled = Math.max(0, Math.round(barW * e.currentHp / e.maxHp));
      drawStr(Math.round(e.col) - 1, drawRow - 2, e.name, '#888');
      drawStr(Math.round(e.col) - 1, drawRow - 1, '[' + '#'.repeat(filled) + '-'.repeat(barW - filled) + ']', '#a55');
    }
  }

  // Hero projectiles
  for (const p of heroProjectiles) {
    const col = Math.round(p.x);
    const row = Math.round(p.y) + 1;
    const color = p.isCrit ? '#ff0' : '#fff';
    drawStr(col, row, '\u25B8', color);
    drawStr(col - 1, row, '\u2500', color);
  }

  drawParticles();

  // HUD
  drawStr(1, 0, `${area.name} - Wave ${STATE.wave + 1}/5`, '#aaa');
  // Level + HP
  const stats = getHeroStats();
  const hpBarW = 20;
  const hpFilled = Math.max(0, Math.round(hpBarW * STATE.heroHp / STATE.heroMaxHp));
  const hpColor = STATE.heroHp / STATE.heroMaxHp > 0.5 ? '#5a5' : (STATE.heroHp / STATE.heroMaxHp > 0.25 ? '#fa5' : '#f55');
  drawStr(35, 0, `Lv${STATE.level} HP [${('#'.repeat(hpFilled) + '-'.repeat(hpBarW - hpFilled))}] ${STATE.heroHp}/${STATE.heroMaxHp}`, hpColor);
  drawStr(85, 0, `Gold: ${STATE.gold + STATE.lootGold}`, '#fd0');

  for (let c = 0; c < COLS; c++) drawStr(c, 1, '\u2550', '#333');

  // Boss HP bar
  for (const e of advState.enemies) {
    if (e.isBoss && e.alive) {
      drawBox(14, 2, 72, 3, ` ${e.name} `, e.color);
      const bBarW = 50;
      const bFilled = Math.max(0, Math.round(bBarW * e.currentHp / e.maxHp));
      drawStr(16, 3, '[' + '#'.repeat(bFilled) + '-'.repeat(bBarW - bFilled) + `] ${e.currentHp}/${e.maxHp}`, '#f55');
    }
  }

  // Boss intro text
  if (advState.phase === 'bossIntro') {
    const boss = advState.enemies[0];
    drawBox(30, 12, 40, 7, null, '#f55');
    drawStr(32, 13, '\u2554' + '\u2550'.repeat(36) + '\u2557', '#f88');
    drawStr(42, 14, '! BOSS !', '#f55');
    drawStr(50 - Math.floor(boss.name.length/2), 16, boss.name, boss.color);
    drawStr(32, 17, '\u255A' + '\u2550'.repeat(36) + '\u255D', '#f88');
  }

  // Chest screen
  if (advState.phase === 'chest') {
    drawBox(25, 6, 50, 24, ' CHEST FOUND! ', '#fd0');
    // Chest ASCII art
    drawStr(40, 9,  '  _______  ', '#fa5');
    drawStr(40, 10, ' /       \\ ', '#fa5');
    drawStr(40, 11, '|  [===]  |', '#fd0');
    drawStr(40, 12, '|_________|', '#fa5');
    drawStr(40, 13, '|         |', '#a85');
    drawStr(40, 14, '|   ___   |', '#a85');
    drawStr(40, 15, '|  |   |  |', '#fd0');
    drawStr(40, 16, '|__|___|__|', '#a85');

    let cy = 18;
    if (advState.chestItem) {
      drawStr(30, cy, `Equipment: ${advState.chestItem.name}`, RARITY_COLORS[advState.chestItem.rarity]);
      cy++;
      let statStr = '';
      if (advState.chestItem.attack) statStr += `ATK+${advState.chestItem.attack} `;
      if (advState.chestItem.defense) statStr += `DEF+${advState.chestItem.defense} `;
      if (advState.chestItem.hp) statStr += `HP+${advState.chestItem.hp} `;
      drawStr(32, cy, statStr, '#888');
      cy++;
    }
    if (advState.chestGold > 0) {
      drawStr(30, cy, `Gold: +${advState.chestGold}`, '#fd0');
      cy++;
    }
    for (const m in advState.chestMaterials) {
      drawStr(30, cy, `${m}: +${advState.chestMaterials[m]}`, '#aaa');
      cy++;
    }
    drawStr(30, Math.min(cy + 1, 27), 'Press Enter to continue', '#888');
  }

  // Victory screen
  if (advState.phase === 'victory') {
    drawBox(20, 6, 60, 24, ' V I C T O R Y ', '#fd0');
    drawStr(35, 9, 'V I C T O R Y !', '#fd0');
    drawStr(30, 12, `Gold earned: ${STATE.lootGold}`, '#fd0');
    let y = 14;
    for (const m in STATE.lootMaterials) {
      drawStr(30, y, `${m}: +${STATE.lootMaterials[m]}`, '#aaa');
      y++;
    }
    if (STATE.loot.length > 0) {
      drawStr(30, y + 1, 'Equipment found:', '#ddd');
      for (let i = 0; i < STATE.loot.length; i++) {
        const item = STATE.loot[i];
        drawStr(32, y + 2 + i, item.name, RARITY_COLORS[item.rarity]);
      }
    }
    drawStr(30, Math.min(y + 4 + STATE.loot.length, 27), 'Press Enter to return to camp', '#888');
  }

  // Bottom stats bar
  drawBox(0, 34, 100, 3, null, '#444');
  drawStr(2, 35, `Lv${STATE.level} ATK:${stats.attack} DEF:${stats.defense} SPD:${stats.attackSpeed.toFixed(1)} CRIT:${(stats.critChance*100).toFixed(0)}%`, '#888');
  const wep = STATE.equipped.weapon;
  const arm = STATE.equipped.armor;
  const acc = STATE.equipped.accessory;
  drawStr(55, 35, `W:${wep ? wep.name : '-'}  A:${arm ? arm.name : '-'}  R:${acc ? acc.name : '-'}`, '#666');
}

function drawLandscape(area) {
  const sx = Math.floor(advState.scrollX);
  const areaIdx = STATE.currentArea;
  const areaColors = ['#553','#668','#66a','#448','#864'];
  const mountainColor = areaColors[areaIdx] || '#444';

  for (let c = 0; c < COLS; c++) {
    const sc = c + Math.floor(sx * 0.05);
    const hash = ((sc * 127 + 311) % 97);
    if (hash < 4) {
      const row = 4 + (hash % 3);
      const twinkle = Math.sin(advState.frame * 0.03 + hash) > 0.2;
      if (twinkle) drawStr(c, row, '.', '#445');
    }
  }

  for (let c = 0; c < COLS; c++) {
    const mc = c + Math.floor(sx * 0.15);
    const mh = Math.sin(mc * 0.08) * 4 + Math.sin(mc * 0.17) * 2 + 6;
    const baseRow = 14;
    for (let r = baseRow - Math.floor(mh); r <= baseRow; r++) {
      if (r >= 7 && r < ROWS) {
        const ch = r === baseRow - Math.floor(mh) ? '^' : '.';
        drawStr(c, r, ch, '#333');
      }
    }
  }

  for (let c = 0; c < COLS; c++) {
    const mc = c + Math.floor(sx * 0.35);
    const mh = Math.sin(mc * 0.2) * 3 + Math.sin(mc * 0.31) * 1.5 + 4;
    const baseRow = 22;
    for (let r = baseRow - Math.floor(mh); r <= baseRow; r++) {
      if (r >= 15 && r < ROWS) {
        const peak = r === baseRow - Math.floor(mh);
        const chars = peak ? '/\\^#' : '/\\|#';
        const ch = chars[(mc + r) % chars.length];
        drawStr(c, r, ch, mountainColor);
      }
    }
  }

  for (let c = 0; c < COLS; c++) {
    const hc = c + Math.floor(sx * 0.6);
    const hh = Math.sin(hc * 0.12) * 1.5 + 2;
    const baseRow = 26;
    for (let r = baseRow - Math.floor(hh); r <= baseRow; r++) {
      if (r >= 23 && r < ROWS) {
        const grassChars = '.,;"`';
        const ch = grassChars[(hc + r) % grassChars.length];
        drawStr(c, r, ch, '#454');
      }
    }
  }

  for (let c = 0; c < COLS; c++) {
    const gc = (c + sx) % 13;
    const ch = gc % 7 === 0 ? 'o' : (gc % 3 === 0 ? '_' : '\u2500');
    drawStr(c, advState.heroRow + 3, ch, '#665');
  }

  for (let c = 0; c < COLS; c++) {
    const gc = (c + sx) % 17;
    const groundPattern = area.landscape.ground;
    const baseCh = groundPattern[gc % groundPattern.length];
    for (let r = advState.heroRow + 4; r < ROWS; r++) {
      const hash = ((c * 13 + r * 7 + sx) % 11);
      const ch = hash === 0 ? 'o' : hash === 1 ? ',' : baseCh || area.groundChar;
      drawStr(c, r, ch, '#554');
    }
  }

  const decoOffset = Math.floor(sx * 0.7);
  for (let i = 0; i < 8; i++) {
    const baseCol = ((i * 29 + 7) - decoOffset % 200 + 400) % 200 - 50;
    if (baseCol < -5 || baseCol >= COLS + 5) continue;
    const col = Math.floor(baseCol);
    if (areaIdx === 0) {
      if (i % 2 === 0) {
        drawStr(col, 24, '+', '#664');
        drawStr(col, 25, '|', '#664');
        drawStr(col - 1, 24, '/', '#553');
        drawStr(col + 1, 24, '\\', '#553');
      } else {
        drawStr(col, 27, 'o~o', '#776');
      }
    } else if (areaIdx === 1) {
      if (i % 2 === 0) {
        drawStr(col, 5, 'V', '#556');
        drawStr(col, 6, '|', '#556');
      } else {
        drawStr(col, 24, '\u2566', '#667');
        drawStr(col, 25, '\u2551', '#667');
        drawStr(col, 26, '\u2551', '#667');
      }
    } else if (areaIdx === 2) {
      if (i % 2 === 0) {
        drawStr(col, 25, '/\\', '#aaf');
        drawStr(col, 24, '*', '#ddf');
      } else {
        drawStr(col, 26, '/\\', '#88d');
        drawStr(col, 27, '||', '#88d');
      }
    } else if (areaIdx === 3) {
      if (i % 2 === 0) {
        drawStr(col, 22, '@@', '#3a3');
        drawStr(col, 23, '@@', '#3a3');
        drawStr(col, 24, '||', '#553');
        drawStr(col, 25, '||', '#553');
      } else {
        drawStr(col, 27, '~"~', '#343');
      }
    } else if (areaIdx === 4) {
      if (i % 2 === 0) {
        drawStr(col, 27, '~v~', '#f52');
        drawStr(col, 28, '^^^', '#f83');
      } else {
        if (advState.frame % 40 < 20) {
          drawStr(col, 25, '*', '#fa4');
          drawStr(col, 24, '^', '#f83');
          drawStr(col, 23, '.', '#f52');
        }
      }
    }
  }

  if (areaIdx >= 3 && Math.random() < 0.15) {
    const ch = areaIdx === 3 ? '~' : '^';
    addParticle(Math.random() * COLS, 25 + Math.random() * 5, ch,
      areaIdx === 3 ? '#336' : '#f52',
      (Math.random()-0.5)*0.1, -0.1, 20);
  }
}

// ============================================================
// FORGE SCENE
// ============================================================
let forgeTab = 0; // 0=craft, 1=upgrade
let forgeCursor = 0;
let forgeUpgradeCursor = 0;
let forgeMessage = '';
let forgeMessageTimer = 0;

function initForge() {
  forgeTab = 0;
  forgeCursor = 0;
  forgeUpgradeCursor = 0;
  forgeMessage = '';
  forgeMessageTimer = 0;
}

function getForgeRecipes() {
  const maxTier = Math.min(STATE.unlockedAreas - 1, 4);
  return EQUIPMENT_TABLE.filter(e => e.tier <= maxTier);
}

function getUpgradeableItems() {
  return STATE.inventory.filter(item => {
    const lvl = item.upgradeLevel || 0;
    return lvl < 3;
  });
}

function getUpgradeCost(item) {
  const tier = item.tier || 0;
  const lvl = (item.upgradeLevel || 0) + 1;
  const materialNames = ['bone','iron','crystal','shadow','ember'];
  return {
    material: materialNames[tier],
    materialAmount: (tier + 1) * 3,
    gold: (tier + 1) * 20
  };
}

function updateForge() {
  if (forgeMessageTimer > 0) forgeMessageTimer--;
  if (wasPressed('Escape')) { filterSort = 0; filterRarity = 0; filterSlot = 0; STATE.scene = 'camp'; return; }
  if (wasPressed('1')) { forgeTab = 0; forgeCursor = 0; filterSort = 0; filterRarity = 0; filterSlot = 0; }
  if (wasPressed('2')) { forgeTab = 1; forgeUpgradeCursor = 0; }

  if (forgeTab === 0) {
    // Craft tab — no filters (recipes, not inventory)
    const recipes = getForgeRecipes();
    if (recipes.length === 0) { getScroll(); return; }
    if (wasPressed('ArrowUp') && forgeCursor > 0) forgeCursor--;
    if (wasPressed('ArrowDown') && forgeCursor < recipes.length - 1) forgeCursor++;
    const scroll = getScroll();
    if (scroll) forgeCursor = Math.max(0, Math.min(recipes.length - 1, forgeCursor + scroll));
    if (wasPressed('Enter')) {
      const recipe = recipes[forgeCursor];
      if (!recipe) return;
      const cost = FORGE_MATERIAL_COSTS[recipe.tier];
      if (STATE.gold >= cost.gold && (STATE.materials[cost.material] || 0) >= cost.amount) {
        STATE.gold -= cost.gold;
        STATE.materials[cost.material] -= cost.amount;
        const newItem = { ...recipe, upgradeLevel: 0 };
        STATE.inventory.push(newItem);
        forgeMessage = `Crafted ${recipe.name}!`;
        forgeMessageTimer = 60;
        saveGame();
      } else {
        forgeMessage = 'Not enough resources!';
        forgeMessageTimer = 60;
      }
    }
  } else {
    // Upgrade tab — with filters
    handleFilterKeys(() => { forgeUpgradeCursor = 0; });
    const items = getFilteredItems(getUpgradeableItems());
    if (items.length === 0) { getScroll(); return; }
    if (forgeUpgradeCursor >= items.length) forgeUpgradeCursor = Math.max(0, items.length - 1);
    if (wasPressed('ArrowUp') && forgeUpgradeCursor > 0) forgeUpgradeCursor--;
    if (wasPressed('ArrowDown') && forgeUpgradeCursor < items.length - 1) forgeUpgradeCursor++;
    const scroll = getScroll();
    if (scroll) forgeUpgradeCursor = Math.max(0, Math.min(items.length - 1, forgeUpgradeCursor + scroll));
    if (wasPressed('Enter')) {
      const item = items[forgeUpgradeCursor];
      if (!item) return;
      const cost = getUpgradeCost(item);
      if (STATE.gold >= cost.gold && (STATE.materials[cost.material] || 0) >= cost.materialAmount) {
        STATE.gold -= cost.gold;
        STATE.materials[cost.material] -= cost.materialAmount;
        item.upgradeLevel = (item.upgradeLevel || 0) + 1;
        // Boost all stats by ~20%
        const mult = 1.2;
        if (item.attack) item.attack = Math.round(item.attack * mult);
        if (item.defense) item.defense = Math.round(item.defense * mult);
        if (item.hp) item.hp = Math.round(item.hp * mult);
        if (item.critChance) item.critChance = parseFloat((item.critChance * mult).toFixed(4));
        if (item.attackSpeed) item.attackSpeed = parseFloat((item.attackSpeed * mult).toFixed(2));
        // Update name with upgrade suffix
        const baseName = item.name.replace(/ \+\d$/, '');
        item.name = `${baseName} +${item.upgradeLevel}`;
        forgeMessage = `Upgraded to ${item.name}!`;
        forgeMessageTimer = 60;
        saveGame();
      } else {
        forgeMessage = 'Not enough resources!';
        forgeMessageTimer = 60;
      }
    }
  }
}

function drawForge() {
  drawBox(0, 0, 100, 3, ' F O R G E ', '#f85');

  // Tabs
  drawStr(3, 4, '[1] Craft', forgeTab === 0 ? '#fff' : '#666');
  drawStr(15, 4, '[2] Upgrade', forgeTab === 1 ? '#fff' : '#666');
  for (let c = 0; c < COLS; c++) drawStr(c, 5, '\u2500', '#444');

  // Resources bar
  drawStr(50, 4, `Gold:${STATE.gold}`, '#fd0');
  let mx = 62;
  for (const m in STATE.materials) {
    if (STATE.materials[m] > 0) {
      drawStr(mx, 4, `${m}:${STATE.materials[m]}`, '#888');
      mx += m.length + String(STATE.materials[m]).length + 2;
    }
  }

  if (forgeTab === 0) {
    // Craft tab
    drawBox(1, 6, 98, 26, ' CRAFT RECIPES ', '#f85');
    drawStr(3, 8, 'NAME                  SLOT       COST              STATS', '#888');
    drawBoxDivider(1, 9, 98, '#553');

    const recipes = getForgeRecipes();
    const maxVisible = 12;
    const startIdx = Math.max(0, forgeCursor - maxVisible + 1);
    for (let i = startIdx; i < Math.min(recipes.length, startIdx + maxVisible); i++) {
      const recipe = recipes[i];
      const cost = FORGE_MATERIAL_COSTS[recipe.tier];
      const selected = i === forgeCursor;
      const canAfford = STATE.gold >= cost.gold && (STATE.materials[cost.material] || 0) >= cost.amount;
      const prefix = selected ? '> ' : '  ';
      const nameColor = RARITY_COLORS[recipe.rarity] || '#aaa';
      const detailColor = selected ? '#fff' : (canAfford ? '#ccc' : '#555');
      const row = 10 + (i - startIdx) * 2;
      const nameStr = recipe.name.padEnd(20);
      const slotStr = recipe.slot.padEnd(10);
      const costStr = `${cost.amount} ${cost.material} + ${cost.gold}g`;
      if (selected) drawStr(3, row, '>', '#fff');
      drawStr(5, row, `${nameStr}`, nameColor);
      drawStr(5 + nameStr.length + 1, row, `${slotStr} ${costStr.padEnd(18)}`, detailColor);
      let statStr = '';
      if (recipe.attack) statStr += `ATK+${recipe.attack} `;
      if (recipe.defense) statStr += `DEF+${recipe.defense} `;
      if (recipe.hp) statStr += `HP+${recipe.hp} `;
      if (recipe.critChance) statStr += `CRIT+${(recipe.critChance*100).toFixed(0)}% `;
      if (recipe.attackSpeed) statStr += `SPD+${recipe.attackSpeed.toFixed(1)}`;
      drawStr(5, row + 1, statStr, '#666');
    }
  } else {
    // Upgrade tab
    drawBox(1, 6, 98, 26, ' UPGRADE ITEMS ', '#fa5');
    drawStr(3, 8, 'NAME                  LEVEL   COST              PREVIEW', '#888');
    drawBoxDivider(1, 9, 98, '#553');

    const items = getFilteredItems(getUpgradeableItems());
    if (items.length === 0) {
      drawStr(3, 11, '(No upgradeable items - craft or find equipment first)', '#555');
    }
    const maxVisible = 10;
    const startIdx = Math.max(0, forgeUpgradeCursor - maxVisible + 1);
    for (let i = startIdx; i < Math.min(items.length, startIdx + maxVisible); i++) {
      const item = items[i];
      const cost = getUpgradeCost(item);
      const selected = i === forgeUpgradeCursor;
      const canAfford = STATE.gold >= cost.gold && (STATE.materials[cost.material] || 0) >= cost.materialAmount;
      const prefix = selected ? '> ' : '  ';
      const nameColor = RARITY_COLORS[item.rarity] || '#aaa';
      const detailColor = selected ? '#fff' : (canAfford ? '#ccc' : '#555');
      const row = 10 + (i - startIdx) * 2;
      const lvl = item.upgradeLevel || 0;
      const nameStr = item.name.padEnd(20);
      const lvlStr = `+${lvl} -> +${lvl+1}`.padEnd(8);
      const costStr = `${cost.materialAmount} ${cost.material} + ${cost.gold}g`;
      if (selected) drawStr(3, row, '>', '#fff');
      drawStr(5, row, `${nameStr}`, nameColor);
      drawStr(5 + nameStr.length + 1, row, `${lvlStr} ${costStr.padEnd(18)}`, detailColor);
      // Preview: show stat boost
      if (selected) {
        let preview = 'After: ';
        const mult = 1.2;
        if (item.attack) preview += `ATK:${Math.round(item.attack * mult)} `;
        if (item.defense) preview += `DEF:${Math.round(item.defense * mult)} `;
        if (item.hp) preview += `HP:${Math.round(item.hp * mult)} `;
        drawStr(5, row + 1, preview, '#5a5');
      }
    }
  }

  if (forgeTab === 1) drawFilterBar(33);
  // Message overwrites filter bar when active
  if (forgeMessageTimer > 0) {
    drawStr(3, 33, forgeMessage, '#5f5');
  }

  drawBox(0, 34, 100, 3, null, '#555');
  drawStr(3, 35, '1/2 tabs  Arrows/Scroll+Enter craft/upgrade  S/R/T filters(upgrade)  Esc leave', '#666');
}

// ============================================================
// ENCHANT SCENE
// ============================================================
let enchantTab = 0; // 0=elemental, 1=reroll
let enchantItemCursor = 0;
let enchantEnchCursor = 0;
let enchantRerollCursor = 0;
let enchantMessage = '';
let enchantMessageTimer = 0;
let enchantRerollPreview = null;
let enchantRerollConfirm = false;

function initEnchant() {
  enchantTab = 0;
  enchantItemCursor = 0;
  enchantEnchCursor = 0;
  enchantRerollCursor = 0;
  enchantMessage = '';
  enchantMessageTimer = 0;
  enchantRerollPreview = null;
  enchantRerollConfirm = false;
}

function getEnchantableItems() {
  return STATE.inventory.filter(item => item.slot && item.slot !== '-');
}

function getAvailableEnchantments() {
  return ENCHANTMENTS.filter(e => e.area < STATE.unlockedAreas);
}

function updateEnchant() {
  if (enchantMessageTimer > 0) enchantMessageTimer--;
  if (wasPressed('Escape')) {
    if (enchantRerollConfirm) {
      enchantRerollConfirm = false;
      enchantRerollPreview = null;
      return;
    }
    filterSort = 0; filterRarity = 0; filterSlot = 0;
    STATE.scene = 'camp';
    return;
  }
  if (wasPressed('1')) { enchantTab = 0; enchantItemCursor = 0; enchantEnchCursor = 0; }
  if (wasPressed('2')) { enchantTab = 1; enchantRerollCursor = 0; enchantRerollPreview = null; enchantRerollConfirm = false; }

  if (enchantTab === 0) {
    // Elemental tab — two-step: pick item, then pick enchantment
    handleFilterKeys(() => { enchantItemCursor = 0; });
    const items = getFilteredItems(getEnchantableItems());
    const enchants = getAvailableEnchantments();
    if (items.length === 0 || enchants.length === 0) { getScroll(); return; }
    if (enchantItemCursor >= items.length) enchantItemCursor = Math.max(0, items.length - 1);

    // ArrowUp/Down scroll item list (left panel)
    if (wasPressed('ArrowUp') && enchantItemCursor > 0) enchantItemCursor--;
    if (wasPressed('ArrowDown') && enchantItemCursor < items.length - 1) enchantItemCursor++;
    // ArrowLeft/Right scroll enchantment list (right panel)
    if (wasPressed('ArrowLeft') && enchantEnchCursor > 0) enchantEnchCursor--;
    if (wasPressed('ArrowRight') && enchantEnchCursor < enchants.length - 1) enchantEnchCursor++;
    // Scroll wheel moves item cursor
    const sd = getScroll();
    if (sd) enchantItemCursor = Math.max(0, Math.min(items.length - 1, enchantItemCursor + sd));

    if (wasPressed('Enter')) {
      const item = items[enchantItemCursor];
      const ench = enchants[enchantEnchCursor];
      if (!item || !ench) return;
      // Cost: 5 of relevant material + 30g
      if (STATE.gold >= 30 && (STATE.materials[ench.material] || 0) >= 5) {
        STATE.gold -= 30;
        STATE.materials[ench.material] -= 5;
        item.enchantment = {
          name: ench.name,
          attack: ench.attack,
          defense: ench.defense,
          hp: ench.hp,
          critChance: ench.critChance,
          attackSpeed: ench.attackSpeed,
          color: ench.color
        };
        enchantMessage = `Applied ${ench.name} to ${item.name}!`;
        enchantMessageTimer = 60;
        saveGame();
      } else {
        enchantMessage = 'Not enough resources! (5 material + 30g)';
        enchantMessageTimer = 60;
      }
    }
  } else {
    // Reroll tab
    handleFilterKeys(() => { enchantRerollCursor = 0; enchantRerollPreview = null; enchantRerollConfirm = false; });
    const items = getFilteredItems(getEnchantableItems());
    if (items.length === 0) { getScroll(); return; }
    if (enchantRerollCursor >= items.length) enchantRerollCursor = Math.max(0, items.length - 1);

    if (enchantRerollConfirm) {
      // Confirm or cancel reroll
      getScroll(); // consume any pending scroll
      if (wasPressed('Enter') || wasPressed('y') || wasPressed('Y')) {
        // Apply reroll
        const item = items[enchantRerollCursor];
        const preview = enchantRerollPreview;
        if (item.attack !== undefined) item.attack = preview.attack;
        if (item.defense !== undefined) item.defense = preview.defense;
        if (item.hp !== undefined) item.hp = preview.hp;
        if (item.critChance !== undefined) item.critChance = preview.critChance;
        if (item.attackSpeed !== undefined) item.attackSpeed = preview.attackSpeed;
        enchantMessage = `Rerolled ${item.name} stats!`;
        enchantMessageTimer = 60;
        enchantRerollConfirm = false;
        enchantRerollPreview = null;
        saveGame();
      } else if (wasPressed('n') || wasPressed('N')) {
        enchantRerollConfirm = false;
        enchantRerollPreview = null;
        enchantMessage = 'Reroll cancelled (resources spent)';
        enchantMessageTimer = 60;
      }
      return;
    }

    if (wasPressed('ArrowUp') && enchantRerollCursor > 0) enchantRerollCursor--;
    if (wasPressed('ArrowDown') && enchantRerollCursor < items.length - 1) enchantRerollCursor++;
    const scroll = getScroll();
    if (scroll) enchantRerollCursor = Math.max(0, Math.min(items.length - 1, enchantRerollCursor + scroll));

    if (wasPressed('Enter')) {
      const item = items[enchantRerollCursor];
      if (!item) return;
      const materialNames = ['bone','iron','crystal','shadow','ember'];
      const mat = materialNames[item.tier || 0];
      // Cost: 3 materials + 20g
      if (STATE.gold >= 20 && (STATE.materials[mat] || 0) >= 3) {
        STATE.gold -= 20;
        STATE.materials[mat] -= 3;
        // Find base stats from EQUIPMENT_TABLE
        const baseName = item.name.replace(/ \+\d$/, '');
        const baseItem = EQUIPMENT_TABLE.find(e => e.name === baseName) || item;
        // Reroll within ±30%
        const reroll = (val) => {
          if (!val) return val;
          const low = Math.round(val * 0.7);
          const high = Math.round(val * 1.3);
          return low + Math.floor(Math.random() * (high - low + 1));
        };
        const rerollFloat = (val) => {
          if (!val) return val;
          const low = val * 0.7;
          const high = val * 1.3;
          return parseFloat((low + Math.random() * (high - low)).toFixed(4));
        };
        enchantRerollPreview = {
          attack: reroll(baseItem.attack),
          defense: reroll(baseItem.defense),
          hp: reroll(baseItem.hp),
          critChance: rerollFloat(baseItem.critChance),
          attackSpeed: rerollFloat(baseItem.attackSpeed)
        };
        // Apply upgrade level multiplier if upgraded
        const lvl = item.upgradeLevel || 0;
        if (lvl > 0) {
          const mult = Math.pow(1.2, lvl);
          if (enchantRerollPreview.attack) enchantRerollPreview.attack = Math.round(enchantRerollPreview.attack * mult);
          if (enchantRerollPreview.defense) enchantRerollPreview.defense = Math.round(enchantRerollPreview.defense * mult);
          if (enchantRerollPreview.hp) enchantRerollPreview.hp = Math.round(enchantRerollPreview.hp * mult);
          if (enchantRerollPreview.critChance) enchantRerollPreview.critChance = parseFloat((enchantRerollPreview.critChance * mult).toFixed(4));
          if (enchantRerollPreview.attackSpeed) enchantRerollPreview.attackSpeed = parseFloat((enchantRerollPreview.attackSpeed * mult).toFixed(2));
        }
        enchantRerollConfirm = true;
      } else {
        enchantMessage = `Not enough resources! (3 ${mat} + 20g)`;
        enchantMessageTimer = 60;
      }
    }
  }
}

function drawEnchant() {
  drawBox(0, 0, 100, 3, ' E N C H A N T ', '#a5f');

  // Tabs
  drawStr(3, 4, '[1] Elemental', enchantTab === 0 ? '#fff' : '#666');
  drawStr(19, 4, '[2] Reroll', enchantTab === 1 ? '#fff' : '#666');
  for (let c = 0; c < COLS; c++) drawStr(c, 5, '\u2500', '#444');

  // Resources
  drawStr(50, 4, `Gold:${STATE.gold}`, '#fd0');
  let mx = 62;
  for (const m in STATE.materials) {
    if (STATE.materials[m] > 0) {
      drawStr(mx, 4, `${m}:${STATE.materials[m]}`, '#888');
      mx += m.length + String(STATE.materials[m]).length + 2;
    }
  }

  if (enchantTab === 0) {
    // Elemental tab
    const items = getFilteredItems(getEnchantableItems());
    const enchants = getAvailableEnchantments();

    // Left: item picker
    drawBox(1, 6, 40, 26, ' SELECT ITEM ', '#a5f');
    if (items.length === 0) {
      drawStr(3, 8, '(No items to enchant)', '#555');
    }
    const maxVisibleItems = 10;
    const itemStartIdx = Math.max(0, enchantItemCursor - maxVisibleItems + 1);
    for (let i = itemStartIdx; i < Math.min(items.length, itemStartIdx + maxVisibleItems); i++) {
      const item = items[i];
      const selected = i === enchantItemCursor;
      const prefix = selected ? '> ' : '  ';
      const enchName = item.enchantment ? ` [${item.enchantment.name}]` : '';
      const color = selected ? '#fff' : RARITY_COLORS[item.rarity];
      drawStr(3, 8 + (i - itemStartIdx) * 2, `${prefix}${item.name}${enchName}`, color);
      if (selected && item.enchantment) {
        drawStr(5, 9 + (i - itemStartIdx) * 2, `Current: ${item.enchantment.name}`, item.enchantment.color);
      }
    }

    // Right: enchantment picker
    drawBox(42, 6, 57, 26, ' SELECT ENCHANTMENT ', '#a5f');
    drawStr(44, 8, 'ENCHANTMENT        COST         BONUS', '#888');
    drawBoxDivider(42, 9, 57, '#446');
    for (let i = 0; i < enchants.length; i++) {
      const e = enchants[i];
      const selected = i === enchantEnchCursor;
      const canAfford = STATE.gold >= 30 && (STATE.materials[e.material] || 0) >= 5;
      const prefix = selected ? '> ' : '  ';
      const color = selected ? '#fff' : (canAfford ? e.color : '#555');
      drawStr(44, 10 + i * 2, `${prefix}${e.name.padEnd(17)} 5 ${e.material} + 30g`, color);
      drawStr(46, 11 + i * 2, e.desc, '#888');
    }
  } else {
    // Reroll tab
    const items = getFilteredItems(getEnchantableItems());
    drawBox(1, 6, 98, 26, ' REROLL STATS ', '#fa5');

    if (items.length === 0) {
      drawStr(3, 8, '(No items to reroll)', '#555');
    }

    if (enchantRerollConfirm && enchantRerollPreview) {
      // Show comparison
      const item = items[enchantRerollCursor];
      drawStr(3, 8, `Rerolling: ${item.name}`, RARITY_COLORS[item.rarity]);
      drawBoxDivider(1, 9, 98, '#553');
      drawStr(3, 10, 'STAT        CURRENT     NEW', '#888');
      let row = 12;
      const stats = ['attack','defense','hp','critChance','attackSpeed'];
      const labels = ['ATK','DEF','HP','CRIT','SPD'];
      for (let s = 0; s < stats.length; s++) {
        const cur = item[stats[s]] || 0;
        const nw = enchantRerollPreview[stats[s]] || 0;
        if (cur === 0 && nw === 0) continue;
        const curStr = stats[s] === 'critChance' ? `${(cur*100).toFixed(1)}%` : (stats[s] === 'attackSpeed' ? cur.toFixed(2) : String(cur));
        const nwStr = stats[s] === 'critChance' ? `${(nw*100).toFixed(1)}%` : (stats[s] === 'attackSpeed' ? nw.toFixed(2) : String(nw));
        const changeColor = nw > cur ? '#5a5' : (nw < cur ? '#f55' : '#888');
        drawStr(3, row, `${labels[s].padEnd(12)} ${curStr.padEnd(12)} ${nwStr}`, changeColor);
        row++;
      }
      drawStr(3, row + 2, 'Accept? [Y] Yes  [N] No  [Esc] Cancel', '#ff0');
    } else {
      drawStr(3, 8, 'NAME                  TIER       COST', '#888');
      drawBoxDivider(1, 9, 98, '#553');
      const maxVisible = 7;
      const startIdx = Math.max(0, enchantRerollCursor - maxVisible + 1);
      for (let i = startIdx; i < Math.min(items.length, startIdx + maxVisible); i++) {
        const item = items[i];
        const materialNames = ['bone','iron','crystal','shadow','ember'];
        const mat = materialNames[item.tier || 0];
        const selected = i === enchantRerollCursor;
        const canAfford = STATE.gold >= 20 && (STATE.materials[mat] || 0) >= 3;
        const prefix = selected ? '> ' : '  ';
        const color = selected ? '#fff' : RARITY_COLORS[item.rarity];
        const row = 10 + (i - startIdx) * 2;
        drawStr(3, row, `${prefix}${item.name.padEnd(20)} T${item.tier || 0}         3 ${mat} + 20g`, color);
        if (!canAfford && !selected) drawStr(70, row, '(need resources)', '#555');
        if (selected) {
          let statStr = '';
          if (item.attack) statStr += `ATK:${item.attack} `;
          if (item.defense) statStr += `DEF:${item.defense} `;
          if (item.hp) statStr += `HP:${item.hp} `;
          if (item.critChance) statStr += `CRIT:${(item.critChance*100).toFixed(0)}% `;
          if (item.attackSpeed) statStr += `SPD:${item.attackSpeed.toFixed(1)}`;
          drawStr(5, row + 1, `Current: ${statStr}`, '#888');
        }
      }
      if (items.length > maxVisible) {
        drawStr(3, 10 + maxVisible * 2, `\u2191\u2193 ${enchantRerollCursor + 1}/${items.length}`, '#666');
      }
    }
  }

  drawFilterBar(33);
  // Message overwrites filter bar when active
  if (enchantMessageTimer > 0) {
    drawStr(3, 33, enchantMessage, '#5f5');
  }

  drawBox(0, 34, 100, 3, null, '#555');
  drawStr(3, 35, '1/2 tabs  Up/Down items  Left/Right enchants  Scroll  S/R/T filters  Esc', '#666');
}

// ============================================================
// INVENTORY SCENE
// ============================================================
let invCursor = 0;

function updateInventory() {
  if (wasPressed('Escape')) { filterSort = 0; filterRarity = 0; filterSlot = 0; STATE.scene = 'camp'; return; }
  handleFilterKeys(() => { invCursor = 0; });
  const filtered = getFilteredItems(STATE.inventory);
  const totalItems = filtered.length;
  if (totalItems === 0) { getScroll(); return; }
  if (invCursor >= totalItems) invCursor = Math.max(0, totalItems - 1);
  if (wasPressed('ArrowUp') && invCursor > 0) invCursor--;
  if (wasPressed('ArrowDown') && invCursor < totalItems - 1) invCursor++;
  const scroll = getScroll();
  if (scroll) invCursor = Math.max(0, Math.min(totalItems - 1, invCursor + scroll));
  if (wasPressed('Enter')) {
    const item = filtered[invCursor];
    if (!item) return;
    const slot = item.slot;
    const current = STATE.equipped[slot];
    if (current) {
      if (current === item || (current.name === item.name && STATE.inventory.indexOf(current) === invCursor)) {
        STATE.equipped[slot] = null;
        return;
      }
    }
    STATE.equipped[slot] = item;
    saveGame();
  }
}

function drawInventory() {
  drawBox(0, 0, 100, 3, ' I N V E N T O R Y ', '#ddd');

  const stats = getHeroStats();
  drawBox(1, 3, 35, 17, ' HERO STATS ', '#fd0');
  drawStr(3, 5, `Max HP: ${stats.maxHp}`, '#5a5');
  drawStr(3, 6, `Attack: ${stats.attack}`, '#f85');
  drawStr(3, 7, `Defense: ${stats.defense}`, '#58f');
  drawStr(3, 8, `Crit: ${(stats.critChance*100).toFixed(0)}%`, '#ff0');
  drawStr(3, 9, `Speed: ${stats.attackSpeed.toFixed(1)}`, '#adf');
  drawBoxDivider(1, 10, 35, '#553');
  drawStr(3, 11, 'Equipped:', '#aaa');
  for (const slot of ['weapon','armor','accessory']) {
    const item = STATE.equipped[slot];
    const row = slot === 'weapon' ? 12 : slot === 'armor' ? 13 : 14;
    let name = item ? item.name : '(none)';
    if (item && item.enchantment) name += ` [${item.enchantment.name}]`;
    drawStr(3, row, `${slot}: ${name}`, item ? RARITY_COLORS[item.rarity] : '#555');
  }
  drawBoxDivider(1, 15, 35, '#553');
  drawStr(3, 16, `Gold: ${STATE.gold}`, '#fd0');
  const matStrs = [];
  for (const m in STATE.materials) {
    if (STATE.materials[m] > 0) matStrs.push(`${m}:${STATE.materials[m]}`);
  }
  if (matStrs.length > 0) drawStr(3, 17, matStrs.join(' '), '#888');

  const filtered = getFilteredItems(STATE.inventory);

  drawBox(37, 3, 62, 17, ' ITEMS ', '#8cf');
  drawStr(39, 4, 'NAME                         SLOT       RARITY', '#888');
  drawBoxDivider(37, 5, 62, '#446');
  if (filtered.length === 0) {
    drawStr(39, 7, '(empty)', '#555');
  }
  const maxVisible = 13;
  const startIdx = Math.max(0, invCursor - maxVisible + 1);
  for (let i = startIdx; i < Math.min(filtered.length, startIdx + maxVisible); i++) {
    const item = filtered[i];
    const selected = i === invCursor;
    const equipped = STATE.equipped[item.slot] === item;
    const prefix = (selected ? '> ' : '  ') + (equipped ? '[E] ' : '    ');
    const color = selected ? '#fff' : RARITY_COLORS[item.rarity];
    let nameStr = item.name;
    if (item.enchantment) nameStr += '*';
    nameStr = nameStr.padEnd(25);
    const slotStr = item.slot.padEnd(10);
    drawStr(39, 6 + (i - startIdx), `${prefix}${nameStr} ${slotStr} ${item.rarity}`, color);
  }

  drawBox(1, 21, 98, 12, ' ITEM DETAILS ', '#888');
  if (filtered.length > 0 && invCursor < filtered.length) {
    const item = filtered[invCursor];
    drawStr(3, 23, item.name, RARITY_COLORS[item.rarity]);
    let subInfo = `Slot: ${item.slot}    Rarity: ${item.rarity}`;
    if (item.upgradeLevel) subInfo += `    Upgrade: +${item.upgradeLevel}`;
    drawStr(3, 24, subInfo, '#888');
    drawBoxDivider(1, 25, 98, '#555');
    let statStr = '';
    if (item.attack) statStr += `ATK+${item.attack}  `;
    if (item.defense) statStr += `DEF+${item.defense}  `;
    if (item.hp) statStr += `HP+${item.hp}  `;
    if (item.critChance) statStr += `CRIT+${(item.critChance*100).toFixed(0)}%  `;
    if (item.attackSpeed) statStr += `SPD+${item.attackSpeed.toFixed(1)}`;
    drawStr(3, 27, statStr, '#aaa');
    if (item.enchantment) {
      drawStr(3, 28, `Enchant: ${item.enchantment.name}`, item.enchantment.color);
    }
    drawStr(3, 29, 'Enter to equip/unequip', '#666');
  } else {
    drawStr(3, 24, 'Select an item to view details', '#555');
  }

  drawFilterBar(33);
  drawBox(0, 34, 100, 3, null, '#555');
  drawStr(3, 35, 'Arrows/Scroll to browse  Enter equip/unequip  S/R/T filters  Esc back', '#666');
}

// ============================================================
// GAME OVER SCENE
// ============================================================
function updateGameOver() {
  if (wasPressed('Enter')) {
    saveGame();
    STATE.scene = 'camp';
  }
}

function drawGameOver() {
  drawBox(20, 6, 60, 22, ' G A M E  O V E R ', '#f33');
  drawStr(35, 10, 'You have fallen in battle...', '#888');
  drawStr(30, 13, `Gold penalty: halved to ${STATE.gold}`, '#fa5');
  drawStr(30, 14, 'Materials kept.', '#5a5');

  if (STATE.lootGold > 0) {
    drawStr(30, 16, `Gold found this run: ${STATE.lootGold} (kept)`, '#fd0');
    STATE.gold += STATE.lootGold;
    STATE.lootGold = 0;
  }
  for (const item of STATE.loot) {
    STATE.inventory.push(item);
  }
  STATE.loot = [];

  drawStr(30, 22, 'Press Enter to return to camp', '#888');
}

// ============================================================
// WIN SCENE
// ============================================================
function drawWinScreen() {
  drawBox(15, 4, 70, 28, ' CONGRATULATIONS ', '#fa5');
  drawStr(25, 10, '* * * C O N G R A T U L A T I O N S * * *', '#fa5');
  drawStr(28, 14, 'You have conquered all five areas!', '#fd0');
  drawStr(28, 16, 'The Ember Lord has been vanquished.', '#f83');
  drawStr(28, 18, 'Peace returns to the stone lands.', '#aaa');
  drawStr(28, 24, 'Press Enter to continue playing', '#888');
  if (wasPressed('Enter')) STATE.scene = 'camp';
}

// ============================================================
// MAIN LOOP
// ============================================================
loadGame();

function gameLoop() {
  clearGrid();
  updateParticles();

  switch (STATE.scene) {
    case 'camp': updateCamp(); drawCamp(); break;
    case 'areaSelect': updateAreaSelect(); drawAreaSelect(); break;
    case 'adventure': updateAdventure(); drawAdventure(); break;
    case 'forge': updateForge(); drawForge(); break;
    case 'enchant': updateEnchant(); drawEnchant(); break;
    case 'inventory': updateInventory(); drawInventory(); break;
    case 'gameOver': updateGameOver(); drawGameOver(); break;
    case 'win': drawWinScreen(); break;
  }

  renderGrid();
  clearInput();
  requestAnimationFrame(gameLoop);
}

gameLoop();
</script>
</body>
</html>
